---
title: 预测分析法
date: 2021-07-15 03:49:38
permalink: /pages/980aa3/
categories: 
  - 编译原理
tags: 
  - null
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
---
# 预测分析法

* 由于一个产生式的右部可能具有多个文法符号，因此在**自顶向下的预测分析**进行匹配时，需要记忆其右部未匹配部分的文法符号
  * 根据实现记忆的方法，分为递归和非递归的预测分析
    * 递归的预测分析借助递归过程实现记忆功能
    * 非递归的预测分析借助栈来实现记忆功能

<!-- more -->

```markmap
- [预测分析法](#预测分析法)
  - [递归的预测分析法](#递归的预测分析法)
  - [非递归的预测分析法](#非递归的预测分析法)
  - [递归的预测分析法与非递归的预测分析法对比](#递归的预测分析法与非递归的预测分析法对比)
  - [预测分析法的实现步骤⭐](#预测分析法的实现步骤)
  - [预测分析中的错误处理](#预测分析中的错误处理)
    - [错误处理的目的 ➕](#错误处理的目的-)
    - [错误检测](#错误检测)
    - [错误恢复](#错误恢复)
      - [恐慌模式](#恐慌模式)
```

---


## 递归的预测分析法

::: theorem 定义
* 递归的预测分析法是指：
  * 在递归下降分析中，根据预测分析表进行产生式的选择
  * 根据每个非终结符的产生式和LL(1)文法的**预测分析表**，**为每个非终结符编写对应的过程**
    * 预测分析表用于应对一个非结结符对应多个产生式的情况
:::

::: note 算法实现
![20210413101504-2021-04-13-10-15-04](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413101504-2021-04-13-10-15-04.png)
* 结合当前输入符号 $a$ 根据 SELECT 表进行选取 $A$ 的产生式
  * 遍历选定的产生式(非 ε-产生式)时
    * 非终结符调用对应的过程
    * 终结符直接与输入符号对比，如果匹配，则继续读入下一个符号；如果不匹配，则报错
  * 如果选定的是 ε-产生式，则可以直接返回 (图中未显示)
  * 如果没有产生式可选，则报错 (图中未显示)
:::

:::details 示例
* 描述程序构造的简单文法
  * ![20210413064720-2021-04-13-06-47-20](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413064720-2021-04-13-06-47-20.png)

    * `TYPE` 表示类型
    * `STLIST` 表示语句序列
    * `DECLIST` 表示标志符的序列
    * `PROGRAM` 表示程序
  * 注意对于 $\varepsilon$-产生式，要针对其 `SELECT` 集进行判断，与 [S_文法](/pages/acf8bd/#s_-文法) 中的示例类似

* 针对非终结符 `PROGRAM` 的程序
  * ![20210413064813-2021-04-13-06-48-13](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413064813-2021-04-13-06-48-13.png)

* 针对非终结符 `DECLIST` 的程序
  * ![20210413065017-2021-04-13-06-50-17](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413065017-2021-04-13-06-50-17.png)

* 针对非终结符 `DECLISTN` 的程序
  * ![20210413065223-2021-04-13-06-52-23](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413065223-2021-04-13-06-52-23.png)
  * 此处相当于根据 `TOKEN` 在 (3)(4) 产生式中进行选择，如果都不满足要求，则报错

* 针对非终结符 `STLIST` 的程序
  * ![20210413065703-2021-04-13-06-57-03](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413065703-2021-04-13-06-57-03.png)

* 针对非终结符 `STLISTN` 的程序
  * ![20210413065803-2021-04-13-06-58-03](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413065803-2021-04-13-06-58-03.png)
  * 此处相当于根据 `TOKEN` 在 (6)(7) 产生式中进行选择，如果都不满足要求，则报错

* 针对非终结符 `TYPE` 的程序
  * ![20210413065831-2021-04-13-06-58-31](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413065831-2021-04-13-06-58-31.png)
  * 此处相当于根据 `TOKEN` 在 (8)(9) 产生式中进行选择，如果都不满足要求，则报错
:::

## 非递归的预测分析法

:::note 基本原理
* 非递归的预测分析不需要为每个非终结符编写递归下降过程，而是根据**预测分析表**构造一个自动机，也叫**表驱动的预测分析**
  * 借助栈当做储存器，可以储存状态，实现记忆的功能，相当于是增加了栈的有穷自动机(下推自动机)
    * 相当是用栈替代了递归的过程
  * 如对于 $L=\{a^n b^b| n\ge 1\}$，碰到 $a$ 即将其压入栈中，碰到  $b$ 后将栈中的 $a$ 弹出一个。如果匹配到末尾，栈为空，则说明 $a, b$ 的个数相同
  :::details 示意图
  ![20210413070409-2021-04-13-07-04-09](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413070409-2021-04-13-07-04-09.png)
  :::


:::details 表驱动的预测分析法的算法实现
* ![20210413080101-2021-04-13-08-01-01](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413080101-2021-04-13-08-01-01.png)
* 初始时将 $\textdollar$ 和文法开始符号压入栈中
* $M[X, a]$ 相当于一个查表过程, $M[X, a]$ 为 `error` 表明相应的语法分析条目为空
* 如果压入的是 ε-产生式，则直接跳过压栈过程
:::

:::details 实例
![20210413070456-2021-04-13-07-04-56](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413070456-2021-04-13-07-04-56.png)
:::

## 递归的预测分析法与非递归的预测分析法对比

|       | 递归的预测分析法            | 非递归的预测分析法                 |
|:-----:|:-------------------:|:-------------------------:|
| 程序规模  | 程序规模**较大**， 不需载入分析表 | 主控程序规模**较小**， 需载入分析表（表较小）😄 |
| 直观性   | 较好   😄               |  较差                       |
| 效率    | 较低                  | 分析时间大约正比于待分析程序的长度     😄   |
| 自动生成  | 较难                  | 较易                  😄      |

::: tip
* 递归的预测分析需要高深度的递归调用，因此效率较低
  * 不需要载入分析表，并不意味着不需分析表。程序的编写仍然需要依据分析表来选择对应的产生式
* 非递归的预测分析法采用的是类似于自动机的方式，容易自动生成程序
:::

## 预测分析法的实现步骤⭐

:::note 实现步骤
* 构造文法
  * [文法的定义](/pages/e070c9/)
* 改造文法：消除二义性、消除左递归、消除[回溯](/pages/8d053f/#回溯)
  * [消除左递归的算法](/pages/8d053f/#消除左递归的算法)
  * 消除回溯的主要方法是[提取左公因子](/pages/8d053f/#提取左公因子的算法)
* 求每个变量的 [FIRST集](/pages/acf8bd/#文法符号串的串首终结符集----first-集)和[FOLLOW集](/pages/acf8bd/#非终结符的后继符号集----follow-集)， 从而求得每个候选式的[SELECT集](/pages/acf8bd/#产生式的可选集----select-集)
  * [FIRST 集的求解方法](/pages/5e8457/#first-集的运算)
  * [FOLLOW 集的求解方法](/pages/5e8457/#follow-集的运算)
  * [SELECT 集的求解方法](/pages/5e8457/#计算-select-集)
* 检查是不是 [LL(1) 文法](/pages/acf8bd/#ll1文法的定义)。若是，构造[预测分析表](/pages/5e8457/#预测分析表)
* 对于[递归的预测分析](#递归的预测分析法)，根据预测分析表为每一个非终结符编写一个过程；对于非递归的预测分析，实现[表驱动的预测分析算法](#非递归的预测分析法)
:::

## 预测分析中的错误处理

### 错误处理的目的 ➕

:::tip
* 如果编译器只处理正确的程序，则它的设计和实现会大大简化；但人们还期望编译器能够帮助程序员定位和跟踪错误
* 大部分的程序设计语言没有规定编译器应该如何处理错误
  * 错误的处理方法由编译器的设计者决定
:::

### 错误检测

:::note 针对非递归的预测分析, 两种情况下可以检测到错误
1. 栈顶的**终结符**和当前输入符号不匹配
2. 栈顶**非终结符**与当前**输入符号**在预测分析表对应项中的信息为空
:::

### 错误恢复

:::tip
* 错误恢复最简单的方法是让语法分析器在检测到第一个错误时给出错误提示信息，然后退出
* 但如果语法分析器给将自己恢复到某个状态，且有理由预期从那里开始处理输入将提供有意义的诊断信息，通常会发现更多的错误
  * 但如果错误太多，最好让编译器在超过某个数量上界之后停止分析
    * 这样，比让编译器产生大量恼人的“可疑”错误信息更好
:::

#### 恐慌模式

:::note 实现方法
* 忽略输入中的一些符号，直到输入中出现由设计者选定的**同步词法单元**(synchronizing token)集合中的**某个词法单元**
  * 其效果依赖于**同步集合的选取**。集合的选取应该使得语法分析器能从实际遇到的错误中**快速恢复**
    * 例如可以把 **$FOLLOW(A)$ 中的所有终结符**放入非终结符 $A$ 的同步记号集合
* 如果终结符在栈顶而不能匹配，一个简单的办法就是弹出此终结符
:::

:::details 示例: 含有同步词法单元的分析表
* ![20210413084352-2021-04-13-08-43-52](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413084352-2021-04-13-08-43-52.png)
* 分析表的使用方法
  * 如果 $M[A,a]$ 是空，表示检测到错误，根据恐慌模式，**忽略输入符号 $a$**
  * 如果 $M[A,a]$ 是 $synch$，表时检测到错误，此时弹出**栈顶的非终结符 $A$**，试图继续分析后面的语法成分
* 如果**栈顶的终结符**和输入符号不匹配，则**弹出栈顶的终结符**
:::

:::details 示例: 借助含有同步词法单元的分析表进行预测分析
* ![20210413084818-2021-04-13-08-48-18](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210413084818-2021-04-13-08-48-18.png)
  * 输入字符串中的起始的字符如果不能匹配，可忽略
:::
