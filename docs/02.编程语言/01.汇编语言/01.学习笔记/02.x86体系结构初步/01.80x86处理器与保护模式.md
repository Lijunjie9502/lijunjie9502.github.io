---
title: 1-80x86处理器与保护模式
date: 2021-04-11 09:38:38
permalink: /pages/89719c/
categories: 
  - 编程语言
  - 汇编语言
  - 01-清华公开课
  - 2-x86体系结构初步
tags: 
  - null
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
---
# 80x86 处理器与保护模式

* [🔗 课件](assets/80X86计算机组织结构简述.pdf)

---

## 80x86 处理器的发展

### 16 位 80X86 微处理器

* 8086/8088 微处理器
* 80186 和 80286 微处理器
  * IBM公司以80286为CPU生产了著名的IBM-PCZAT微型计算机，它的许多技术被沿用至今

### 32 位的 80x86 微处理器

* 80386
  * 1985 年， Intel 公司推出的第四代32位微处理器
  * 其有 3 种工作模式：**实地址模式**，**虚地址保护模式**和**虚拟8086模式**

## 32 位微处理器的寄存器

* 80X86微处理器由16位升级为32位后，它的寄存器也对应升级为32位
* 为了新的工作方式和存储管理的需要，增加了一些用于控制的寄存器

### 数据寄存器

* 16位80X86处理器原有的4个通用数据寄存器扩展为32位，命名为EAX、EBX、ECX和EDX
* 仍然可以使用原有的16位和8位寄存嚣，如AX、BX、CX、DX、AH、AL、BH、BL.....
  * 保持向下兼容
  <!--sec data-title="数据寄存器示意图" data-id="section20210411095400" data-show=true ces-->
  ![20210411095426-2021-04-11-09-54-26](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210411095426-2021-04-11-09-54-26.png)
  <!--endsec-->

### 地址寄存器

* 原有的4个主要用于内存寻址的通用寄存器同样扩展为32位，命名为 ES1、ED1、EBP、ESP
  * 在实地址模式下仍然可以使用诛有的16位寄存器S1、D1、BP和SP 。
* 指令指针寡存器扩展为32位，更名为EIP，实地址下仍然可以使用它的低16位IP

<!--sec data-title="地址寄存器示意图" data-id="section20210411095750" data-show=true ces-->
![20210411095809-2021-04-11-09-58-09](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210411095809-2021-04-11-09-58-09.png)
<!--endsec-->

* 在原有的4个段寄存器 (CS DS SS ES) 基础上上，增加了2个新的段寡存器FS和GS
  * 段寄存器长度均为16位，其中13位代表内存段的一个编号，称为“**段选择器**”

## 80x86 的三种工作模式

* 实模式
  * 操作相当于一个可进行32位快速运算的8086
* 保护模式
  * 是80x86设计目标全部达到的工作模式
  * 通过对程序使用的存储区采用分段、分页的存储管理机制，达到分级使用、互不干扰的保护目的
    * **支持多任务处理功能**
  * 能为每个任务提供一台虚拟处理器，使每个任务单独执行，快速切换
    * **支持虚拟储存器特性**
* 虚拟8086模式
  * 保护模式下同时模拟多个8086处理器.

## 保护模式下的 80X86(段模式)

* 保护模式中“保护”的含义
  * 分清不同程序使用的存储区域，不允许随便使用别人的数据和代码
    * 必要条件
      * 要标记每段存储区的所有者或被使用的权限级别
      * 要标记使用者是谁(权限级别)
      * 中间环节: CPU要去判断此次访问是否合法

### 保护模式下的储存器寻址

* 在X86-32体系结构的保护模式下，一个内存地址是由段基地址、偏移地址两个要素构成的
  * 通过段选择器查询描述符表，来得到相应的段基地址
  <!--sec data-title="通过段基地址和内存地址访问内存的示意图" data-id="section20210411101621" data-show=true ces-->
  ![20210411101702-2021-04-11-10-17-02](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210411101702-2021-04-11-10-17-02.png)
  <!--endsec-->

* 每个段的描述(即段描述符) 由三个要系构成一一段基地址 (32位):段长度(20位，段长
度单位为$2^{12}$(4 KB)): 访问权限
  * 段描述符的长度为64位

* 出于系统兼容原因，段寄存器只有16位，因为要通过描述符表的映射来表示64位的段描述符
  * 将段寄存器中的高13位值作为索引来访问描述符表，从而获得64位的段描述符

#### GDT 与 LDT

* GDT是全局描述符表，主要存放操作系统和各任务公用的描述符
  * 公用的数据和代码段描述符、各任务的 TSS 描述符和 **LDT 描述符**
    * TSS 是任务状态段，存放各个任务私有运行状态信息描述符
  * GDT register (GDTR) ，48bit
    * GDT 表的储存地址
* LDT 是局部描述符表，主要存放各个任务的私有描述符
  * LDT register(LDTR), 16 bit
    * 记录 LDT 描述符在 GDT 中的位置
* 段寄存器:
  * 高13位用来指示描述符在描述符表中的索引号
  * 低两位是表示使用描述符的特权级别
  * 另外一位 (T1) 是GDT和LDT的信号量，如果T1=0，则使用GDT，如果T1=1，则使用LDT

<!--sec data-title="访问GDT示例" data-id="section20210411104059" data-show=true ces-->
![访问GDT-2021-04-11-10-41-56](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/访问GDT-2021-04-11-10-41-56.png)

* 首先通过 GDTR 确定 GDT 的位置
* 然后通过段寄存器中的索引值访问 GDT， 取出相应的描述符
<!--endsec-->

<!--sec data-title="访问 LDT 示例" data-id="section20210411104445" data-show=true ces-->
![访问LDT-2021-04-11-10-48-40](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/访问LDT-2021-04-11-10-48-40.png)

* 首先通过 GDTR 确定 GDT 的位置
* 然后通过 LDTR 中的索引值从 GDT 中取出 LDT 描述符（即 LDT 的起始位置）
* 最后段寄存器的的索引值取出对应的描述符

相当于是双重索引
<!--endsec-->

#### 寄存器与储存器的比较

| 项目   | 寄存器      | 储存器      |
|:----:|:--------:|:--------:|
| 位置   | 在 CPU 内部 | 在 CPU 外部 |
| 访问速度 | 快        | 慢        |
| 容量   | 小        | 大        |
| 成本   | 高        | 低        |
| 表示方式 | 用名字表示    | 用地址表示    |
| 地址   | 没有       | 可用多种方式表示 |
