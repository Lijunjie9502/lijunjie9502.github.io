---
title: 基本指令
date: 2021-04-12 06:49:07
permalink: /pages/135dcb/
categories: 
  - 汇编语言
tags: 
  - null
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
---

# 80X86 汇编与 C 语言 -- 基本指令

## 汇编程序员眼中的处理器系统结构

<!--sec data-title="CPU 和内存空间结构示意图" data-id="section20210412071236" data-show=true ces-->
![20210412071251-2021-04-12-07-12-51](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412071251-2021-04-12-07-12-51.png)
<!--endsec-->

* 指令寄存器(PC Program Counter)
  * 指向下一条指令的地址
  * EIP(X86-32) 或 RIP(x86-64)
* 寄存器堆
* 条件码
  * 用于储存最近执行指令的结果状态信息
  * 用于条件跳转指令的判断
* 内存空间
  * 以字节编码的连续存储空间
  * 存放程序代码、数据、运行栈以及操作系统数据

## 从 C 生成汇编代码

<!--sec data-title="C 代码" data-id="section20210412091202" data-show=true ces-->

```c
int sum(int x, int y)
{
  int t = x + y;
  return t;
}
```
<!--endsec-->

<!--sec data-title="命令行编译" data-id="section20210412091229" data-show=true ces-->
* `gcc -O2 -S sum.c -m32 -fno-omit-frame-pointer -fno-asynchronous-unwind-tables`
  * `-O2` 是优化的级别
  * `-m32` 是选择 32 位的 CPU
  * `-S` 生成汇编代码
  * `-fno-asynchronous-unwind-tables` 禁止输出一些信息
    * [🔗 参考](https://cloud.tencent.com/developer/ask/102663/answer/182019)
<!--endsec-->

<!--sec data-title="对应的 X86-32汇编(AT&T 汇编格式)" data-id="section20210412091306" data-show=true ces-->
```nasm
sum:
  pushl %ebp
  movl  %esp, %ebp
  movl  12(%ebp), %eax
  addl  8(%ebp), %eax
  movl  %ebp, %esp
  popl  %ebp
  ret
```

* 其中第6，7行指令可能是一条等价的 `leave` 指令或者是 `pop %ebp` 指令
<!--endsec-->

## 汇编语言数据格式

* 在 X86-32 中，使用 “字(word)” 来表示 16 位整数类型，“双字”表示 32 位
* 汇编语言中没有数据类型，一般采用汇编指令后缀进行区分

<!--sec data-title="X86-32中的各种数据格式" data-id="section20210412090955" data-show=true ces-->
| C 声明            | Intel 数据类型 | 汇编代码后缀 | 大小(字节) |
|-----------------|------------|--------|--------|
| `char`          | 字节         | b      | 1      |
| `short`         | 字          | w      | 2      |
| `int`           | 双字         | l      | 4      |
| `long int`      | 双字         | l      | 4      |
| `long long int` | --         | --     | 4      |
| `char *`        | 双字         | l      | 4      |
| `float`         | 单精度        | s      | 4      |
| `double`        | 双精度        | l      | 8      |
| `long double`   | 扩展精度       | t      | 10/12  |
<!--endsec-->

## 第一条汇编指令实例

<!--sec data-title="C代码" data-id="section20210412091417" data-show=true ces-->
* 两个整数(32位)相加
  
  ```c
  int t = x + y
  ```
<!--endsec-->

<!--sec data-title="汇编代码" data-id="section20210412091545" data-show=true ces-->
* 两个32位整数相加

  ```nasm
  addl %edx, %eax
  ```

  * `l` 后缀表示是双字运算
  * 无符号/带符号整数加法运算的指令是一样的
  * 与 C 语言的操作数对应  
    `x: Register eax`  
    `y: Register edx`  
    `t: Register eax`  
      `>> 最终结果存于 eax`
<!--endsec-->

<!--sec data-title="机器码" data-id="section20210412092143" data-show=true ces-->

```nasm
a:  01  d0    add %edx, %eax
```

* 2 字节指令

<!--endsec-->

## 数据传送指令(MOV)

<!--sec data-title="数据传递(AT&T 语法)" data-id="section20210412092749" data-show=true ces-->
* `movl Source, Dest`
  * 将一个“双字”从 `Source` 移动到 `Dest`
  * 常见指令
<!--endsec-->

<!--sec data-title="允许的操作数类型" data-id="section20210412092955" data-show=true ces-->
* 立即数（Imm）：常整数
  * 如： `$0x400`, `$-533`
  * 可又被1，2或4个字节表示
* 寄存器
  * 8 个通用寄存器  
    ![20210412093155-2021-04-12-09-31-55](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412093155-2021-04-12-09-31-55.png)
* 存储器：四个连续字节
  * 支持多种访存寻址模式
<!--endsec-->

<!--sec data-title="数据传输指令支持的不同操作数类型组合" data-id="section20210412093310" data-show=true ces-->
![20210412093411-2021-04-12-09-34-11](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412093411-2021-04-12-09-34-11.png)  

* **不能两个操作数都为内存地址！**
* 通用寄存器加括号是通用的寻址形式，参照 [🔗 通用寻址形式](#通用寻址形式)
<!--endsec-->

### 符号扩展与零扩展

<!--sec data-title="当 Source 占用字节小于 Dest 占用字节时，需要对 Source 中的数据进行扩展" data-id="section20210412112211" data-show=true ces-->
![20210412112408-2021-04-12-11-24-08](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412112408-2021-04-12-11-24-08.png)
<!--endsec-->

## 寻址模式

### 简单的寻址模式

* 间接寻址
  * 寄存器 `R` 中指定内存地址， 则 `(R)` 相当于是 `Mem[Reg[R]]`
  * 指令： `movl (%ecx), %eax`
* 基址+偏移量寻址
  * 寄存器 `R` 中指定内存起始地址，常数 `D` 给出偏移量
    * `D(R)` 等价于 `Mem[Reg[R]+D]`
  * 指令： `movl 8(%ebp), %edx`

<!--sec data-title="简单寻址模式使用实例" data-id="section20210412105214" data-show=true data-collapse=true ces-->
* C 代码与汇编码  
  ![20210412105345-2021-04-12-10-53-45](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412105345-2021-04-12-10-53-45.png)
  * 其中 SetUp 与 Finish 与栈帧的操作相关，会在后续内容中介绍。Body 部分是函数的主体
  * 寄存器与 C 中变量的对应  
    ![20210412105544-2021-04-12-10-55-44](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412105544-2021-04-12-10-55-44.png)
  * 初始时栈帧的情况  
    ![20210412105623-2021-04-12-10-56-23](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412105623-2021-04-12-10-56-23.png)
    * `%ebp` 指向的是栈帧的基址
      * 其往上可以访问父函数传递的参数
      * 往下可以访问函数内部的局部变量
* 汇编代码的执行过程  
  ![mov指令-2021-04-12-10-58-49](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/mov指令-2021-04-12-10-58-49.gif)
<!--endsec-->

### 通用寻址形式

* `D(Rb, Ri, S)` ➡️ `Mem[Reg[Rb] + S * Reg[Ri] + D]`
  * `D`: 常量(地址偏移量)
  * `Rb`: 基址寄存器
    * 8 个通用寄存器之一
  * `Ri`: 索引寄存器
    * `%esp` 不能作为索引寄存器
    * 一般 `%ebp` 也不用作此用途
  * `S`: 比例因了 1，2， 4， or 8

<!--sec data-title="通用寻址模式实例" data-id="section20210412111142" data-show=true ces-->
* 设寄存器 `%edx` 的值为 `0xf200`，寄存器 `%ecx` 的值为 `0x100`

| 地址表达式           | 地址计算               | 访存地址    |
|:---------------:|:------------------:|:-------:|
| 0x8             | 0x8                | 0x8     |
| 0x8(%edx)       | 0xf200 + 0x8       | 0xf208  |
| (%dex, %exc)    | 0xf200 + 0x100     | 0xf300  |
| (%dex, %ecx, 4) | 0xf200 + 4 * 0x100 | 0xf600  |
| 0x80(, %edx, 2) | 2 * 0xf200 + 0x80  | 0x1e480 |

* 如果是 `$0x8`， 则表示立即数；否则就是内存地址

<!--endsec-->

## 地址计算指令

* `leal Src, Dest`
  * `Src` 为地址计算表达式
  * 计算出来的地址赋给 `Dest`
  * `mov` 指令会访存，`leal` 不会

<!--sec data-title="地址计算指令使用示例" data-id="section20210412113014" data-show=true ces-->
* 地址计算(无需访存)
  * 比如计算元素的地址， `p = &x[i];`
* 进行 `x + k * y, k=1,2,4, or 8` 这一类型的整数计算
  * 其形式与寻址计算相同，参照 [🔗 通用寻址形式](#通用寻址形式)
  * 借助 `leal` 指令会比加减乘除指令快
<!--endsec-->

## 整数计算指令

<!--sec data-title="双操作数指令" data-id="section20210412114607" data-show=true ces-->

| 指令格式              | 计算                |
|:-----------------|:-----------------:|
| `addl   Src, Dest` | `Dest = Dest + Src` |
| `subl   Src, Dest` | `Dest = Dest - Src` |
| `imull  Src, Dest` | `Dest = Dest * Src` |
| `sall   Src, Dest` | `Dest = Dest << Src`  与 `shll` 等价|
| `sarl   Src, Dest` | `Dest = Dest >> Src`  算术右移|
| `shrl   Src, Dest` | `Dest = Dest >> Src`  逻辑右移|
| `xorl  Src, Dest` | `Dest = Dest ^ Src` |
| `andl  Src, Dest` | `Dest = Dest & Src` |
| `orl  Src, Dest` | `Dest = Dest | Src` |

<!--endsec-->

<!--sec data-title="单操作数指令" data-id="section20210412114641" data-show=true ces-->

| 指令格式              | 计算                |
|:-----------------|:-----------------:|
| `incl Dest` | `Dest = Dest + 1` |
| `decl Dest` | `Dest = Dest - 1` |
| `negl Dest` | `Dest = - Dest` |
| `notl Dest` | `Dest = ~ Dest` |

<!--endsec-->

<!--sec data-title="实例1: 将 leal 指令用于计算" data-id="section20210412120937" data-show=true data-collapse=true ces-->

* C 代码

  ```c
  int arith(int x, int y, int z)
  {
    int t1 = x + y;
    int t2 = z + t1;
    int t3 = x  + 4;
    int t4 = y * 48;
    int t5 = t3 + t4;
    int rval = t2 * t5;
    return rval;
  }
  ```

* 汇编码

  ```nasm
  arith:
    pushl %ebp
    movl  %esp, %ebp

    movl  8(%ebp), %ecx
    movl  12(%ebp), %edx
    leal  (%ecx,%edx), %eax
    leal  (%edx,%edx,2), %edx
    addl  16(%ebp), %eax
    sall  $4, %edx
    leal  4(%ecx,%edx), %edx
    imull %edx, %eax

    popl %ebp
    ret

  ```

* 汇编码与 C 代码的对应  
  ![20210412121300-2021-04-12-12-13-00](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412121300-2021-04-12-12-13-00.png)

<!--endsec-->

<!--sec data-title="实例2: 整数计算指令" data-id="section20210412121319" data-show=true data-collapse=true ces-->
* C 代码

  ```c
  int logical(int x, int y)
  {
    int t1 = x^y;
    int t2 = t1 >> 17;
    int mask = (1<<13) - 7;
    int rval = t2 & mask;
    return rval;
  }
  ```

* 汇编代码

  ```nasm
  logical:
    pushl %ebp
    movl  %esp, %ebp
    movl  12(%ebp), %eax
    xorl  8(%ebp), %eax
    popl  %ebp
    sarl  $17, %eax
    andl  $8185, %eax
    ret
  ```

* 汇编代码与 C 语言的对应  
  ![20210412121911-2021-04-12-12-19-11](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412121911-2021-04-12-12-19-11.png)
<!--endsec-->

## X86-32 与 X86-64 比较

### X86-32 与 X86-64 的数据类型宽度

<!--sec data-title="Size of C objects(in Bytes)" data-id="section20210412122225" data-show=true ces-->
![20210412122258-2021-04-12-12-22-58](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412122258-2021-04-12-12-22-58.png)
<!--endsec-->

### x86-64 的通用寄存器

* 其扩展了现有的寄存器，并增加了 8 个新的寄存器
* `%ebp, %rbp` 不再是专用寄存器

<!--sec data-title="x86-64的通用寄存器示意图" data-id="section20210412122411" data-show=true ces-->
![20210412122440-2021-04-12-12-24-40](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412122440-2021-04-12-12-24-40.png)
<!--endsec-->

### 两者汇编代码的不同之处

<!--sec data-title="x86-32 下的 swap" data-id="section20210412123051" data-show=true data-collapse=true ces-->
  ![20210412105345-2021-04-12-10-53-45](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412105345-2021-04-12-10-53-45.png)
<!--endsec-->

<!--sec data-title="x86-64下的 swap" data-id="section20210412123307" data-show=true data-collapse=true ces-->
![20210412123332-2021-04-12-12-33-32](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412123332-2021-04-12-12-33-32.png)

* x86-64 与 x86-32 的不同点
  * 参数通过寄存器来传递
    * 当参数少于 7 个时，参数从左到右放入寄存器：`rdi, rsi, rdx, rcx, r8, r9`
    * 当参为 7 个以上时，前 6 个传递方式不变，但后面的依次从“右向左”放入栈中
  * 相当于是无栈操作

* 被操作的数据仍是 32 位
  * 所以使用的寄存器仍是 `%eax, %edx` 以及 `movl` 指令
<!--endsec-->

<!--sec data-title="x86-64下 long int 的 swap 过程" data-id="section20210412124158" data-show=true data-collapse=true ces-->
![20210412124259-2021-04-12-12-43-00](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210412124259-2021-04-12-12-43-00.png)  

* 被操作的数据是 64 位
  * 所又使用寄存器 `%rax`, `%rdx`
  * 又及 `movq` 指令
    * `q` 表示 “4字”
<!--endsec-->
