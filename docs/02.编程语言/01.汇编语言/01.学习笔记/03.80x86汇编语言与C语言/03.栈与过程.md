---
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
title: 栈与过程
date: 2021-08-20 20:47:39
permalink: /pages/41e121/
categories: 
  - 
tags: 
  - 
---

# 栈与过程

```markmap
- [栈与过程](#栈与过程)
  - [x86-32 的程序栈](#x86-32-的程序栈)
    - [压栈操作](#压栈操作)
    - [出栈操作](#出栈操作)
  - [x86-32 的过程调用](#x86-32-的过程调用)
    - [基于栈的编程语言](#基于栈的编程语言)
    - [栈帧](#栈帧)
    - [寄存器使用惯例](#寄存器使用惯例)
    - [递归调用](#递归调用)
  - [x86-64 的过程调用](#x86-64-的过程调用)
    - [x86-64 通用寄存器](#x86-64-通用寄存器)
```

## x86-32 的程序栈

* 符合“栈(stack)“ 工作原理的一块内存区域
  * 从高地址向低地址”增长“

### 压栈操作

### 出栈操作

## x86-32 的过程调用

* 利用栈支持过程调用与返回

### 基于栈的编程语言

* 代码可重入
  * 同时有同一个过程的多个实例在运行
* 因此需要有一块区域来存储每个过程实例的数据
  * 参数
  * 局部变量
  * 返回地址

* 每个过程实例的运行时间是有限的，即栈的有效时间有限
  * From when called to when return
* 被调用者先千调用者返回（一般情况下）

* 每个过程实例在栈中维护一个栈帧 (stack frame)

### 栈帧

* x86-32/Linux 下的栈帧

:::note 当前栈帧的内容(自"顶"向下)
* 子过程参数
  * "Argument build"
* 局部变量
  * 因为通用寄存器个数有限
* 被保存的寄存器的值
* 父过程的栈帧起始地址(`old %ebp`)
:::

:::note 父过程的栈帧中与当前过程相关的内容
* 返回地址
  * 由 `call` 指令存入
  * `4(%ebp)`
* 当前过程的输入参数
  * `8(%ebp)` 对应第 1 个输入参数
  * `12(%ebp)` 对应第 2 个输入参数
  * 参数从右向左压
:::

* Swap 过程
  * `pushl %ebx` 保存寄存器，防止父过程也要调用

* `ret` 要使用 `esp`

### 寄存器使用惯例

:::note 寄存器的使用约定
* 示意图
  :::details
  ![20210903093924-2021-09-03-09-39-24](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210903093924-2021-09-03-09-39-24.png)
* 两个特殊的寄存器
  * `%ebp, %esp`
* 三个由被调用者负责保存
  * `%ebx, %esi, %edi`
* 三个由调用者负责保存
  * `%eax, %edx, %ecx`
* `%eax` 用于保存过程返回值
:::

### 递归调用

* 运算尽量用寄存器做
* 实例


* 使用栈来存储临时变量

* 带有指针的"阶乘"过程
  * 由于由 `&` 取地址，所以变量必须存储于栈中
  * 加 16 byte 是考虑到x86-32 中栈 16 byte 对齐的问题

## x86-64 的过程调用

### x86-64 通用寄存器

* 寄存器使用惯例(软件上的约定，与硬件无关)
  :::details
  ![20210903102713-2021-09-03-10-27-13](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/20210903102713-2021-09-03-10-27-13.png)
  :::
  * Argument 由被调用者保存

* swap 函数示例
  * `volatile`
  * `%rsp` 往下 `128` 个 byte 是可以安全使用的
* `swap-3`
  * x86-64 加入了新的寻址方式 scount(%rip)
* swap-4
  * `jmp swap`
    * `swap` 调用 `ret` 时，相当于返回的是 `swap_ele` 这个程序的返回地址
