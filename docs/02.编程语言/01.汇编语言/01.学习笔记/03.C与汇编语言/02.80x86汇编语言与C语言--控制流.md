---
title: 02-80x86汇编语言与C语言--控制流
date: 2021-04-14 10:49:50
permalink: /pages/1bdb27/
categories: 
  - 编程语言
  - 汇编语言
  - 01-清华公开课
  - 3-C与汇编语言
tags: 
  - null
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
---
# 80x86 汇编与 C 语言 -- 控制流

* [🔗 课件](./assets/80x86汇编与C语言2.pdf)

---

## 汇编程序员眼中的系统结构(部分)

<!--sec data-title="示意图" data-id="section20210414105330" data-show=true data-collapse=true ces-->
![20210414105348-2021-04-14-10-53-48](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414105348-2021-04-14-10-53-48.png)

* 反映了当前执行程序的信息
  * 数据
  * 指令地址
  * 运行栈地址
  * 条件码
<!--endsec-->

## 条件码

* 条件码由**算术指令隐含设置**
  * 如：`addl Src,Dest`， `addq Src,Dest`
  * 类似的C语言表达式: `t=a+b` (`a=Src, b = Dest`)

* 四个条件码
  * CF进位标志 (Carry)
    * 可用于检测无符号整数运算的溢出
  * SF 符号位 (Sign)
    * 如果 `t < 0`， 那么 `SF=1`; 否则 `SF=0`
  * ZF Zero Flag
    * 如果 `t == 0`，那么 `ZF=1`; 否则 `ZF=0`
  * OF 溢出标志 (Overflow)
    * 如果补码运算溢出，那么 `OF=1` (即带符号整数运算 )
    * 补码溢出的判断条件
    * `(a>0 && b>0 && t<0) || (a<0 && b<0 && t>=0)`

## 比较指令

`cmp1 Src2 Src1`  &nbsp;&nbsp;&nbsp;&nbsp;  `cmpq Src2, Src1`

* `cmpl b,a` 类似于计算 `a-b` (但是不改变目的操作数)
* 如果向最高位有借位，那么 `CF=1`; 否则 `CF=0`
  * 可用于无符号数的比较
* 如果 `a == b`，那么 `ZF=1`; 否则 `ZF=0`
* 如果 `(a - b) < 0`(指结果的最高位为 `1`)，那么 `SF=1`; 否则 `SF=0`
  * 即运算后若结果最高位为 `1`，那么 `SF=1`; 否则为 `0`
* 如果补码运算溢出，那么 `OF=1`
  * `(a>0 && b<0 && (a-b)<0) || (a<0 && b>0 && (a-b)>0)`

## 测试 (Test) 指令

`testl Src2 Src1`  &nbsp;&nbsp;&nbsp;&nbsp;  `testq Src2, Src1`

* 计算 `Src1 & Src2` 并设置相应的条件码，但是不改变目的操作数
  * 如果 `a&b == 0`，那么 `ZF=1`; 否则为 `0`
  * 如果 `a&b < 0` ，那么 `SF=1`; 否则为 `0`
  * 即运算后结果最高位为 `1`，那么`SF=1`; 否则为`0`
* `test` 指令会将 `CF`, `OF` 标志位清零

## 读取条件码

<!--sec data-title="SetX 指令的具体内容" data-id="section20210414121321" data-show=true data-collapse=true ces-->

| SetX    | Condition        | Description              |
|:-------:|:----------------:|:------------------------:|
| `sete`  | `ZF`             | Equal / Zero             |
| `setne` | `~ZF`            | Not Equal / Not Zero     |
| `sets`  | `SF`             | Negative                 |
| `setns` | `~SF`            | Nonnegative              |
| `setg`  | `~(SF^OF) & ~ZF` | Greater(Signed)          |
| `setge` | `~(SF^OF)`      | Greater or Equal(Signed) |
| `setl`  | `(SF^OF)`       | Less (Signed)            |
| `setle` | `(SF^OF) $|$ZF`    | Less or Equal(Signed)    |
| `seta`  | `~CF&~ZF`        | Above (unsigned)         |
| `setb`  | `CF`             | Below (unsigned)         |

<!--endsec-->


* SetX 指令的操作
  * 读取当前的条件码（或者某些条件码的组合)，并存入目的**字节**寄存器
    * 余下的三个字节不会修改
      * ![20210414121449-2021-04-14-12-14-49](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414121449-2021-04-14-12-14-49.png)
    * 通常会使用 `movzbl` 指令对目的寄存器进行 `0` 扩展

  <!--sec data-title="示例" data-id="section20210414122514" data-show=true data-collapse=true ces-->
  * C 代码

    ```c
    int gt(int x, int y)
    {
      return x > y;
    }
    
    ```

  * 汇编码

    ```nasm
    movl  12(%ebp), %eax  # eax = y
    cmpl  %eax, 8(%ebp)   # Compare x, y
    setg  %al             # al = x > y
    movzbl  %al, %eax     # Zero rest of %eax, 程序会返加 %eax 中的值
    ```
  <!--endsec-->

#### x86-64 下的读取条件码

* SetX 指令的操作
  * 读取当前的条件码（或者某些条件码的组合)，并存入目的**字节**寄存器
  * 寄存器中的余下 7 个字节不会被更改

<!--sec data-title="示例" data-id="section20210414123234" data-show=true data-collapse=true ces-->

* C 代码

  ```c
  long lgt(long x, long y)
  {
    return x > y;
  }
  ```

* 汇编码

  ```nasm
  xorl  %eax, %eax  # eax=0
  cmpq  %rsi, %rdi  # Compare x:y
  setg  %al         # al = x > y
  ```

  * 可以看出汇编码中只对 `%eax` 进行了处理， 即 `%rax` 的高 32 位
    * ![20210414124855-2021-04-14-12-48-55](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414124855-2021-04-14-12-48-55.png)
    * 这是因为技术手册中规定如果 32 位的运算产生了32位的结果，则自动的在目标通用寄存器的高 32 位进行零扩展
      <!-- TODO:数据项依赖的具体含义，为何这样做可又消除数据项依赖-->
      * 部分原因来自于微体系结构内部实现的效率方面的考虑，目的是为了消除“部分数据依赖”
<!--endsec-->

## 跳转指令

<!--sec data-title="指令的具体内容" data-id="section20210414162309" data-show=true data-collapse=true ces-->

| jX    | Condition        | Description              |
|:-------:|:----------------:|:------------------------:|
| `je`  | `ZF`             | Equal / Zero             |
| `jne` | `~ZF`            | Not Equal / Not Zero     |
| `js`  | `SF`             | Negative                 |
| `jns` | `~SF`            | Nonnegative              |
| `jg`  | `~(SF^OF) & ~ZF` | Greater(Signed)          |
| `jge` | `~(SF^OF)`      | Greater or Equal(Signed) |
| `jl`  | `(SF^OF)`       | Less (Signed)            |
| `jle` | `(SF^OF) $|$ZF`    | Less or Equal(Signed)    |
| `ja`  | `~CF&~ZF`        | Above (unsigned)         |
| `jb`  | `CF`             | Below (unsigned)         |

<!--endsec-->

* `jx`
  * 依赖当前的条件码选择下一条执行语句（是否顺序执行）

<!--sec data-title="跳转指令的实例" data-id="section20210414162657" data-show=true data-collapse=true ces-->
* C 代码与汇编代码
  * ![20210414162731-2021-04-14-16-27-31](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414162731-2021-04-14-16-27-31.png)
  * gcc-4.8 下没有摸索出如何编译出这种汇编代码，只有加上 `-march=i386` 才可以得到类似的结果，不然出来的是条件传送指令 `cmovC`
* 汇编代码与 C 代码原始的 "goto" 模式类似
  * ![20210414162748-2021-04-14-16-27-48](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414162748-2021-04-14-16-27-48.png)
* 也与 C 语言的条件表达式类似
  * ![20210414163307-2021-04-14-16-33-08](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414163307-2021-04-14-16-33-08.png)
<!--endsec-->

## 条件传送指令

* `cmovC src, dest`
  * 如果条件 C 成立，将数据从 `src` 传送至 `dest`
  * 从执行的角度看，比一般的条件跳转指令的效率高
    * 因为其控制流可预测，不会出现跳转执行的情况

<!--sec data-title="条件传送指令实例" data-id="section20210414164704" data-show=true data-collapse=true ces-->

* x86-64 下对于 `absdiff` 来说，会用条件传送指令来替换条件跳转指令
  ![20210414165210-2021-04-14-16-52-10](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414165210-2021-04-14-16-52-10.png)
* 在 `-m32` 编译选项下，如果加上 `-march=i686` 选项，也可编译出采用条件传送指令的汇编代码
  * ![20210414165434-2021-04-14-16-54-34](https://cdn.jsdelivr.net/gh/Lijunjie9502/PicBed@master/20210414165434-2021-04-14-16-54-34.png)

<!--endsec-->
