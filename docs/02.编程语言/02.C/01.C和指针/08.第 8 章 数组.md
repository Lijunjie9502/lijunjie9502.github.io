---
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
title: 第 8 章 数组
date: 2021-09-15 12:41:12
permalink: /pages/606dd4/
categories: 
  - 
tags: 
  - 
---

# 第 8 章 数组

```markmap
- [第 8 章 数组](#第-8-章-数组)
  - [一维数组](#一维数组)
    - [数组名](#数组名)
    - [下标引用](#下标引用)
    - [指针与下标](#指针与下标)
    - [指针的效率](#指针的效率)
    - [数组和指针](#数组和指针)
    - [作为函数参数的数组名](#作为函数参数的数组名)
    - [声明数组参数](#声明数组参数)
    - [初始化](#初始化)
    - [不完整的初始化](#不完整的初始化)
    - [自动计算数组长度](#自动计算数组长度)
    - [字符数组的初始化](#字符数组的初始化)
  - [多维数组](#多维数组)
    - [存储顺序](#存储顺序)
    - [数组名](#数组名-1)
    - [下标](#下标)
    - [指向数组的指针](#指向数组的指针)
    - [作为函数参数的多维数组](#作为函数参数的多维数组)
    - [初始化](#初始化-1)
    - [数组长度自动计算](#数组长度自动计算)
  - [指针数组](#指针数组)
  - [总结](#总结)
  - [问题](#问题)
  - [编程练习](#编程练习)
```

## 一维数组

::: details 书本内容
![8-1-2021-09-15-12-42-08](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-2021-09-15-12-42-08.png)
:::

### 数组名

::: details 书本内容
![8-1-1-2021-09-15-12-43-49](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-1-2021-09-15-12-43-49.png)
:::

### 下标引用

::: details 书本内容
![8-1-2-2021-09-15-12-44-59](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-2-2021-09-15-12-44-59.png)
:::

### 指针与下标

::: details 书本内容
![8-1-3-2021-09-15-12-46-27](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-3-2021-09-15-12-46-27.png)
:::

### 指针的效率

::: details 书本内容
![8-1-4-2021-09-15-12-47-38](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-4-2021-09-15-12-47-38.png)
:::

### 数组和指针

::: details 书本内容
![8-1-5-2021-09-15-12-49-35](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-5-2021-09-15-12-49-35.png)
:::

### 作为函数参数的数组名

::: details 书本内容
![8-1-6-2021-09-15-12-51-38](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-6-2021-09-15-12-51-38.png)
:::

### 声明数组参数

::: details 书本内容
![8-1-7-2021-09-15-12-53-07](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-7-2021-09-15-12-53-07.png)
:::

::: warning
* 仅仅作为函数形参时，`char *string` 和 `char string[]` 才是相等的
* 在其它上下文环境中，此两者并不相等
  * > [参考问题8](#q8)
:::


### 初始化

::: details 书本内容
![8-1-8-2021-09-15-12-54-17](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-8-2021-09-15-12-54-17.png)
:::

### 不完整的初始化

::: details 书本内容
![8-1-9-2021-09-15-12-55-21](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-9-2021-09-15-12-55-21.png)
:::

### 自动计算数组长度

::: details 书本内容
![8-1-10-2021-09-15-12-56-34](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-10-2021-09-15-12-56-34.png)
:::

### 字符数组的初始化

::: details 书本内容
![8-1-11-2021-09-15-12-57-02](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-1-11-2021-09-15-12-57-02.png)
:::

## 多维数组

::: details 书本内容
![8-2-2021-09-15-12-59-52](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-2021-09-15-12-59-52.png)
:::

### 存储顺序

::: details 书本内容
![8-2-1-2021-09-15-12-59-33](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-1-2021-09-15-12-59-33.png)
:::

### 数组名

::: details 书本内容
![8-2-2-2021-09-15-13-01-47](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-2-2021-09-15-13-01-47.png)
:::

### 下标

::: details 书本内容
![8-2-3-2021-09-15-13-02-04](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-3-2021-09-15-13-02-04.png)
:::

### 指向数组的指针

::: details 书本内容
![8-2-4-2021-09-15-13-03-20](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-4-2021-09-15-13-03-20.png)
:::

### 作为函数参数的多维数组

::: details 书本内容
![8-2-5-2021-09-15-13-04-43](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-5-2021-09-15-13-04-43.png)
:::

### 初始化

::: details 书本内容
![8-2-6-2021-09-15-13-04-58](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-6-2021-09-15-13-04-58.png)
:::

### 数组长度自动计算

::: details 书本内容
![8-2-7-2021-09-15-13-05-14](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-2-7-2021-09-15-13-05-14.png)
:::

## 指针数组

::: details 书本内容
![8-3-2021-09-15-13-06-33](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-3-2021-09-15-13-06-33.png)
:::

## 总结

::: details 书本内容
![8-4-2021-09-15-13-06-46](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/8-4-2021-09-15-13-06-46.png)
:::

## 问题

<br>
<h6 id='q1' class='anchor-user-defined'>
<a href='#q1' class='header-anchor'>#</a>
</h6>

::: note 问题 1
1．根据下面给出的声明和数据，对每个表达式进行求值并写出它的值。在对每个表达式进行求值时使用原先给出的值（也就是说，某个表达式的结果不影响后面的表达式）。假定 `ints` 数组在内存中的起始位置是100，整型值和指针的长度都是4个字节。

```c
int ints[20] = {
10, 20, 30, 40, 50, 60, 70, 80, 90, 100,
110, 120, 130, 140, 150, 160, 170, 180, 190, 200
};
/* ( Other declarations ) */
int *ip = ints + 3;
```

:::details 答案
| 表达式        | 值     | 表达式      | 值    |
| :------------ | :----- | :---------- | :---- |
| `ints`        | `100`  | `ip`        | `112` |
| `ints[4]`     | `50`   | `ip[4]`     | `80`  |
| `ints + 4`    | `116`  | `ip + 4`    | `128` |
| `*ints + 4`   | `14`   | `*ip + 4`   | `44`  |
| `*(ints + 4)` | `50`   | `*(ip + 4)` | `80`  |
| `ints[-2]`    | 非法   | `ip[-2]`    | `20`  |
| `&ints`       | `100`  | `&ip`       | 未知  |
| `&ints[4]`    | `116`  | `&ip[4]`    | `128` |
| `&ints + 4`   | `116`  | `&ip + 4`   | 未知  |
| `&ints[-2]`   | `非法` | `&ip[-2]`   | `104` |
:::

<h6 id='q2' class='anchor-user-defined'>
<a href='#q2' class='header-anchor'>#</a>
</h6>

::: note 问题 2
表达式 `array[i+j]` 和 `i+j[array]` 是不是相等？
:::details 答案
* 不相等，第 2 个表达式等价于 `array[j] + i`
:::


<h6 id='q3' class='anchor-user-defined'>
<a href='#q3' class='header-anchor'>#</a>
</h6>

::: note 问题 3
3．下面的声明试图按照从1开始的下标访问数组 `data`，它能行吗？

```c
int actual_data[ 20 ];
int *data = actual_data - 1;
```

:::details 答案
* 可行，但是如果程序试图使用 `*data`，则会导致不可预料的结果
:::


<h6 id='q4' class='anchor-user-defined'>
<a href='#q4' class='header-anchor'>#</a>
</h6>

::: note 问题 4
4. 下面的循环用于测试某个字符串是否是回文，请对它进行重写，用指针变量代替下标。

```c
char buffer[SIZE];
int front, rear;

front = 0;
rear = strlen( buffer ) - 1;
while( front < rear ){
  if( buffer[front] != buffer[rear] )
  break;
  front += 1;
  rear -= 1;
}
if( front >= rear ){
  printf( "It is a palindrome!\n" );
}
```

:::details 答案
* 代码

  <<<docs/02.编程语言/02.C/01.C和指针/code/ch8/q4.c#code

:::


<h6 id='q5' class='anchor-user-defined'>
<a href='#q5' class='header-anchor'>#</a>
</h6>

::: note 问题 5
指针在效率上可能强于下标，这是使用它们的动机之一。那么什么时候使用下标是合理的，尽管它在效率上可能有所损失？
:::details 答案
* 一般情况下，使用下标均是合理的
* 因为一般情况下，一个程序 80% 的运行时间用于执行 20% 的代码，所以其他 80% 的代码对效率不是很敏感
  * 因此使用指针获得的效率上的提升，可能抵不上其他方面(如可维护性)的损失
:::

<h6 id='q6' class='anchor-user-defined'>
<a href='#q6' class='header-anchor'>#</a>
</h6>

::: note 问题 6
在你的机器上编译函数try1至try5，并分析结果的汇编代码。你的结论是什么？
<br><br>
⌛tag+todo CSAPP 学完后再来做
:::details 答案
:::

<h6 id='q7' class='anchor-user-defined'>
<a href='#q7' class='header-anchor'>#</a>
</h6>

::: note 问题 7
测试你对前一个问题的结论，方法是运行每一个函数并对它们的执行时间进行计时。把数组的元素增加到几千个，增加试验的准确性，因为此时复制所占用的时间远远超过程序不相关部分所占用的时间。同样，在一个循环内部调用函数，让它重复执行足够多的次数，这样你可以精确地为执行时间计时。为这个试验两次编译程序——一次不使用任何优化措施，另一次使用优化措施。如果你的编译器可以提供选择，请选择优化措施以获得最佳速度。
<br><br>
⌛tag+todo 查 C 如何对运行时间计时
:::details 答案
:::


<h6 id='q8' class='anchor-user-defined'>
<a href='#q8' class='header-anchor'>#</a>
</h6>

::: note 问题 8
下面的声明取自某个源文件：

```c
int a[10];
int *b = a;
```

但在另一个不同的源文件中，却发现了这样的代码：

```c
extern int *a;
extern int b[];
int x, y;
...
x = a[3];
y = b[3];
```

请解释一下，当两条赋值语句执行时会发生什么？（假定整型和指针的长度都是4个字节。）

:::details 答案
* 第一条赋值语句，编译器认为 `a` 是一个整型指针变量，因此 `a[3]` 会首先取出其中储存在 `a` 中的值，然后再加上 `12`
  * 但是 `a` 实际上存放的是一个整型数组，将 `a` 当做一个整型指针变量，取其中存储的值，实际上是取数组的前 4 个字节(与整型指针的长度相同，对于整型数组，其提取的是数组的第 1 个元素)。然后再加上 12 后，结果被解释为地址，再对其进行间接访问
  * 作为结果，其要么返回对应地址的值(此值往往是不可预测的); 要么由于地址错误而导致程序失败(大多数会是这种情况)
* 第二条赋值语句，编译器认为 `b` 是一个数组名，所以 12 会加到 `b` 的存储地址，然后间接访问操作会从那里提取值。但事实上， `b` 是一个指针，其储存的地址是不可预计的，将其地址向后偏移 12 再读取的内容是不可预料的。
::: warning
指针和数组虽然存在关联，但两者绝不是等同的
:::

## 编程练习

