---
author: 
  name: 木子识时务
  link: https://github.com/sbwcwso
editLink: true
title: 第 9 章 字符串 字符和字节
date: 2021-09-15 13:07:21
permalink: /pages/c88c45/
categories: 
  - 
tags: 
  - 
---

# 第 9 章 字符串 字符和字节

::: details 书本内容
![9-0-2021-09-15-13-12-18](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-0-2021-09-15-13-12-18.png)
:::

<!-- more -->

```markmap
- [第 9 章 字符串 字符和字节](#第-9-章-字符串-字符和字节)
  - [字符串基础](#字符串基础)
  - [字符串长度](#字符串长度)
  - [不受限制的字符串函数](#不受限制的字符串函数)
    - [复制字符串](#复制字符串)
    - [连接字符串](#连接字符串)
    - [函数的返回值](#函数的返回值)
    - [字符串比较](#字符串比较)
  - [长度受限的字符串函数](#长度受限的字符串函数)
  - [字符串查找基础](#字符串查找基础)
    - [查找一个字符](#查找一个字符)
    - [查找任何几个字符](#查找任何几个字符)
    - [查找一个子串](#查找一个子串)
  - [高级字符串查找](#高级字符串查找)
    - [查找一个字符串前缀](#查找一个字符串前缀)
    - [查找标记](#查找标记)
  - [错误信息](#错误信息)
  - [字符操作](#字符操作)
    - [字符分类](#字符分类)
    - [字符转换](#字符转换)
  - [内存操作](#内存操作)
  - [总结](#总结)
  - [问题](#问题)
  - [编程练习](#编程练习)
```

## 字符串基础

::: details 书本内容
![9-1-2021-09-15-13-29-19](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-1-2021-09-15-13-29-19.png)
:::

## 字符串长度

::: details 书本内容
![9-2-2021-09-15-13-30-41](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-2-2021-09-15-13-30-41.png)
:::

## 不受限制的字符串函数

::: details 书本内容
![9-3-2021-09-15-13-31-21](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-3-2021-09-15-13-31-21.png)
:::

### 复制字符串

::: details 书本内容
![9-3-1-2021-09-15-13-31-38](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-3-1-2021-09-15-13-31-38.png)
:::

### 连接字符串

::: details 书本内容
![9-3-2-2021-09-15-13-32-50](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-3-2-2021-09-15-13-32-50.png)
:::

### 函数的返回值

::: details 书本内容
![9-3-3-2021-09-15-14-44-48](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-3-3-2021-09-15-14-44-48.png)
:::

### 字符串比较

::: details 书本内容
![9-3-4-2021-09-15-14-49-02](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-3-4-2021-09-15-14-49-02.png)
:::

## 长度受限的字符串函数

::: details 书本内容
![9-4-2021-09-15-14-50-10](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-4-2021-09-15-14-50-10.png)
:::

## 字符串查找基础

::: details 书本内容
![9-5-2021-09-15-14-51-22](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-5-2021-09-15-14-51-22.png)
:::

### 查找一个字符

::: details 书本内容
![9-5-1-2021-09-15-14-53-40](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-5-1-2021-09-15-14-53-40.png)
:::

### 查找任何几个字符

::: details 书本内容
![9-5-2-2021-09-15-14-54-29](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-5-2-2021-09-15-14-54-29.png)
:::

### 查找一个子串

::: details 书本内容
![9-5-3-2021-09-15-14-55-31](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-5-3-2021-09-15-14-55-31.png)
:::

## 高级字符串查找

::: details 书本内容
![9-6-2021-09-15-14-56-36](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-6-2021-09-15-14-56-36.png)
:::

### 查找一个字符串前缀

::: details 书本内容
![9-6-1-2021-09-15-14-56-50](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-6-1-2021-09-15-14-56-50.png)
:::

### 查找标记

::: details 书本内容
![9-6-2-2021-09-15-14-57-53](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-6-2-2021-09-15-14-57-53.png)
:::

## 错误信息

::: details 书本内容
![9-7-2021-09-15-14-58-36](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-7-2021-09-15-14-58-36.png)
:::

## 字符操作

::: details 书本内容
![9-8-2021-09-15-14-58-58](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-8-2021-09-15-14-58-58.png)
:::

### 字符分类

::: details 书本内容
![9-8-1-2021-09-15-15-00-03](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-8-1-2021-09-15-15-00-03.png)
:::

### 字符转换

::: details 书本内容
![9-8-2-2021-09-15-15-00-23](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-8-2-2021-09-15-15-00-23.png)
:::

## 内存操作

::: details 书本内容
![9-9-2021-09-15-15-00-47](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-9-2021-09-15-15-00-47.png)
:::

## 总结

::: details 书本内容
![9-10-2021-09-15-15-01-53](https://cdn.jsdelivr.net/gh/sbwcwso/PicBed@master/9-10-2021-09-15-15-01-53.png)
:::

## 问题

<br>

<h6 id='q1' class='anchor-user-defined'>
<a href='#q1' class='header-anchor'>#</a>
</h6>


::: note 问题 1
C语言缺少显式的字符串数据类型，这是一个优点还是一个缺点？
:::details 答案

* 优点
  * 操纵字符数组的效率和访问的灵活性
* 缺点
  * 有可能引起错误：溢出数组，使用的下标超出了字符串的边界
  * 无法改变任何用于保存字符串的数组的长度等

* 现代的面向对象的技术中的字符串类毫无例外地包括了完整的错误检查、用于字符串的动态内存分配和其他一些防护措施
  * 这些措施都会造成效率上的损失
  * 但是，如果程序无法运行，效率再高也没有什么意义
  * 而且，较之设计C语言的时代，现代软件项目的规模要大得多

* 由于这个方法内在的危险性，所以使用现代的高级的、完整的字符串类还是物有所值的
* 但如果C程序员愿意循规蹈矩地使用字符串，也可以获得上述优点
:::

<h6 id='q2' class='anchor-user-defined'>
<a href='#q2' class='header-anchor'>#</a>
</h6>

::: note 问题 2
 `strlen` 函数返回一个无符号量 `(size_t)` ，为什么这里无符号值比有符号值更合适？但返回无符号值其实也有缺点，为什么？
:::details 答案
* 优点
  * 无符号值更加符合具体含义，因为字符串的长度不可能是负值
  * 在同等的字节数下，无符号值表示的范围比有符号值大，可能返回更长的字符串的长度
* 缺点
  * 涉及无符号值的运算极易因疏忽而出现问题
:::

<h6 id='q3' class='anchor-user-defined'>
<a href='#q3' class='header-anchor'>#</a>
</h6>

::: note 问题 3
如果 `strcat` 和 `strcpy` 函数返回一个指向目标字符串末尾的指针，和事实上返回一个指向目标字符串起始位置的指针相比，有没有什么优点？
:::details 答案
* 优点是可以更加高效的完成后续的串联操作，因为不再需要重复的查找字符串的末尾
:::

<h6 id='q4' class='anchor-user-defined'>
<a href='#q4' class='header-anchor'>#</a>
</h6>

::: note 问题 4
如果从数组 `x` 复制 `50` 个字节到数组 `y` ，最简单的方法是什么?
:::details 答案
* 不能直接使用 `str---` 函数，因为此类函数碰到第 1 个 `\0`(NUL) 字节时，即会停止
* 可以使用 `memcpy` 进行内存复制
  * `memcpy(y, x, 50)`
:::

<h6 id='q5' class='anchor-user-defined'>
<a href='#q5' class='header-anchor'>#</a>
</h6>

::: note 问题 5
假定你有一个名叫 `buffer` 的数组，它的长度为 `BSIZE` 个字节，你用下面这条语句把一个字符串复制到这个数组：

```c
strncpy( buffer, some_other_string, BSIZE - 1 );
```

它能不能保证 `buffer` 中的内容是一个有效的字符串？

:::details 答案
* 不能，因为当 `strlen(some_other_string) >= strlen(buffer)` 时， `strncpy` 不能保证 buffer 以 `NUL` 字节结尾
* 为了确保不发生错误，可按下列语句操作

  ```c
  char buffer[BSIZE];
  ...
  strncpy(buffer, name, BSIZE);
  buffer[BSIZE - 1] = '\0'
  ```

* 参照 [长度受限的字符串函数](#长度受限的字符串函数)
:::

<h6 id='q6' class='anchor-user-defined'>
<a href='#q6' class='header-anchor'>#</a>
</h6>

::: note 问题 6
用下面这种方法

```c
if( isalpha( ch ) ){
```

取代下面这种显式的测试有什么优点？

```c
if( ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z' ){
```

:::details 答案
* 前者适用于任何字符集，而后者只适合 `ASCII` 码
* 前者的可移植性较强，后者可移植性较差
:::


<h6 id='q7' class='anchor-user-defined'>
<a href='#q7' class='header-anchor'>#</a>
</h6>

::: note 问题 7
下面的代码怎样进行简化？

```c
for( p_str = message; *p_str != '\0'; p_str++ ){
  if( islower( *p_str ) )
    *p_str = toupper( *p_str );
  }
```

:::details 答案

```c
for( p_str = message; *p_str != '\0'; p_str++ )
  *p_str = toupper( *p_str );
```

:::

## 编程练习
